/**
 * @file Timer.c
 *
 * @author     Omar Ayman (omar.ayman@crewteq.com)
 * @brief      Source file of (Timer) Component
 * @version    1.0.0
 * @date       2024-03-06
 *
 * @copyright  Copyright (crewteq.com) 2024
 */

/*______________________INCLUDES________________________________*/
#include "Timer.h"
#include "GPIO.h"
/*__________________ -Macros- _________________*/

/*__________________ -Public- _________________*/

PUBLIC TIM_HandleTypeDef htim2;
PUBLIC TIM_HandleTypeDef htim3;
PUBLIC void MX_TIM3_Init(void);
/// @brief this array contains the received 100 bits from SAE1850 Bus.
 u8_t  u8_arr_BufferSae1850[100]; 
/*_________________ - Privates _______________*/

/// @brief this is just copy paste of MX_TIM2 initialization generated by cube MX,
///        this Api is reponsible for initializing the timer2 for sending High and Low bits of the SAE1850 PWM protocol
/// @param  NAN
/// @return NAN
PRIVATE void vid_TimInitFreeRunning(void)
{

  /* USER CODE BEGIN TIM2_Init 0 */

  /* USER CODE END TIM2_Init 0 */

  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
  TIM_MasterConfigTypeDef sMasterConfig = {0};

  /* USER CODE BEGIN TIM2_Init 1 */

  /* USER CODE END TIM2_Init 1 */
  htim2.Instance = TIM2;
  htim2.Init.Prescaler = 0;
  htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim2.Init.Period = 1536;
  htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  if (HAL_TIM_Base_Init(&htim2) != HAL_OK)
  {
    Error_Handler();
  }
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
  if (HAL_TIM_ConfigClockSource(&htim2, &sClockSourceConfig) != HAL_OK)
  {
    Error_Handler();
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_UPDATE;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN TIM2_Init 2 */
 
  /* USER CODE END TIM2_Init 2 */

}

/// @brief when receiving is done this bit is = 1 
PRIVATE             u8_t            u8BufferIsFull      = 0 ;

/// @brief this flag is set just in case the timer2 initialization is Done successfully.
PRIVATE             u8_t            u8InitIsDone        = 0 ; 

/// @brief sending low bit in progress.
PRIVATE             u8_t            u8LOWInProgress     = 0; 

/// @brief sending high bit in progress.
PRIVATE             u8_t            u8HIGHInProgress    = 0;

/// @brief this array contains the Low and High bits (Ton duration in us)
PRIVATE             enumTonInUs_e   arrHighLowSAE[2]    = {TON_16_US,TON_8_US};

 
 
/*___________________ - Implementations- _______________*/
enumRetTimer_e enum_TimerInit(void)
{
    /*----------Locals----------*/
    enumRetTimer_e LOC_enumRetVal = UNKOWN_TIMER;
    /*----------Action Here ! ---------*/

    /* init FREE_RUNNIG_TIMER_MODE*/
    vid_TimInitFreeRunning();

    u8InitIsDone=1;
    if(enum_GpioWritePin(PANDA_GREEN_LED_GPIO_Port,PANDA_GREEN_LED_Pin,GPIO_PIN_RESET)!=VALID_GPIO)
    {
      LOC_enumRetVal = NOT_VALID_TIMER;
    }
    else 
    {
      LOC_enumRetVal = VALID_TIMER;
    }
    /* return */
    return LOC_enumRetVal;
}

enumRetTimer_e enum_TimerSetPeriod(enumSAElogic_e enumHighLow)
{
    /*----------Locals----------*/
    enumRetTimer_e LOC_enumRetVal = UNKOWN_TIMER;

    /* --- Stop Receiving -----*/ 
    HAL_NVIC_DisableIRQ(EXTI0_IRQn);
    HAL_NVIC_DisableIRQ(EXTI9_5_IRQn);
    /*----------Action Here ! ---------*/
    if((u8InitIsDone == 1 ) && (enumHighLow <= SAE_HIGH))
    {
        LOC_enumRetVal = VALID_TIMER;
        if (enumHighLow == SAE_LOW)
        {
          /*----- this is the logic for sending LOW bit (TON  = 16 us , TOFF = 8 us) ----*/
            arrHighLowSAE[0] = TON_16_US;
            arrHighLowSAE[1] = TON_8_US;
             /*----- this bit =  0 when the sending LOW bit is Done successfully ----*/
            u8LOWInProgress = 1 ;
            __HAL_TIM_ENABLE_IT(&htim2, TIM_IT_UPDATE);
            __HAL_TIM_ENABLE(&htim2); 
            while(u8LOWInProgress==1){/*---- Wait ---*/}
            __HAL_TIM_DISABLE(&htim2);
        }
        else if (enumHighLow == SAE_HIGH)
        {
          /*----- this is the logic for sending HIGH bit (TON  = 8 us , TOFF = 16 us) ----*/
            arrHighLowSAE[0] = TON_8_US; 
            arrHighLowSAE[1] = TON_16_US;
          /*----- this bit =  0 when the sending HIGH bit is Done successfully ----*/
            u8HIGHInProgress = 1 ;
            __HAL_TIM_ENABLE_IT(&htim2, TIM_IT_UPDATE);
            __HAL_TIM_ENABLE(&htim2);
            while(u8HIGHInProgress==1){/*---- Wait ---*/}
            __HAL_TIM_DISABLE(&htim2);
        }
        else 
        {
            LOC_enumRetVal = NOT_VALID_TIMER;
        }    
    }
    else 
    {
      LOC_enumRetVal = NOT_VALID_TIMER;
    }
    
    return LOC_enumRetVal;
}

enumRetTimer_e enum_TimerWaitToGetPeriod(void)
{
    /*----------Locals----------*/
    enumRetTimer_e LOC_enumRetVal = UNKOWN_TIMER;

    if(u8InitIsDone == 1)
    {
      /* ------ Enable Receiving & stop transmission----- */
      HAL_NVIC_EnableIRQ(EXTI0_IRQn);
      HAL_NVIC_EnableIRQ(EXTI9_5_IRQn);
      HAL_TIM_Base_Stop_IT(&htim2);
      
      /*----------Action Here ! ---------*/
      while(u8BufferIsFull==0){/*--- wait receiption ---*/}
      LOC_enumRetVal = VALID_TIMER;
      u8BufferIsFull = 0; 
    }
    else 
    {
      LOC_enumRetVal = NOT_VALID_TIMER;
    }
    return LOC_enumRetVal;
}

void TIM2_IRQHandler(void)
{
  /* USER CODE BEGIN TIM2_IRQn 0 */
  
  /* ---- this is algorithm to send just one bit -----*/
  
  /// @brief this counter is used in the algorithm of sending the LOW and HIGH bits of the SAE1850 frame
  PRIVATE             u8_t            u8TIM2counter       = 0 ;
  
  __HAL_TIM_DISABLE(&htim2);
  
    enum_GpioTogglePin(PANDA_GREEN_LED_GPIO_Port,PANDA_GREEN_LED_Pin);
    u8TIM2counter++;
     /*----- set the ARR register for sending the first transtion of the bit ----*/
    if(u8TIM2counter == 1){htim2.Instance->ARR = arrHighLowSAE[0]; }
     /*----- set the ARR register for sending the second transtion of the bit ----*/
    else if(u8TIM2counter == 2)
    {
        htim2.Instance->ARR = arrHighLowSAE[1];
        u8TIM2counter=0;
        u8HIGHInProgress = 0 ;
        u8LOWInProgress=0;
        htim2.Instance->CNT = 0x0000;
    } 
     __HAL_TIM_CLEAR_IT(&htim2, TIM_IT_UPDATE);
     __HAL_TIM_ENABLE(&htim2);
  


  /* ---- this is algorithm to send just one bit -----*/


  /* USER CODE END TIM2_IRQn 0 */
  
  /* USER CODE BEGIN TIM2_IRQn 1 */
   
  /* USER CODE END TIM2_IRQn 1 */
  
}

void EXTI0_IRQHandler(void)
{
  /* USER CODE BEGIN EXTI0_IRQn 0 */
  
  /* -----RISING Edge Detector ---- */
  htim3.Instance->CNT = 0 ; 
  HAL_TIM_Base_Start(&htim3);
  
  /* USER CODE END EXTI0_IRQn 0 */
  HAL_GPIO_EXTI_IRQHandler(RISING_Edge_Pin_Pin);
  /* USER CODE BEGIN EXTI0_IRQn 1 */

  /* USER CODE END EXTI0_IRQn 1 */
}

void EXTI9_5_IRQHandler(void)
{
  /* USER CODE BEGIN EXTI9_5_IRQn 0 */

   /* -----RISING Edge Detector ---- */
  PRIVATE u8_t counter = 0 ;
  
  u8_arr_BufferSae1850[counter]=  __HAL_TIM_GET_COUNTER(&htim3);
  counter++;
  if(counter == 101){u8BufferIsFull = 1; counter = 0 ;}

  /* USER CODE END EXTI9_5_IRQn 0 */
  HAL_GPIO_EXTI_IRQHandler(FALLING_EDGE_Pin_Pin);
  /* USER CODE BEGIN EXTI9_5_IRQn 1 */

  /* USER CODE END EXTI9_5_IRQn 1 */
}